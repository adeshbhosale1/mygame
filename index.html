<!doctype html>
<html lang="mr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Snake Game - HTML/CSS/JS</title>
  <style>
    :root{
      --bg: #0f1724;
      --panel: #0b1220;
      --accent: #00d1b2;
      --danger: #ff6b6b;
      --text: #e6f0ff;
    }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial,Helvetica,sans-serif;background:linear-gradient(180deg,#071022 0%, #0f1724 100%);color:var(--text);}
    .wrap{min-height:100%;display:flex;align-items:center;justify-content:center;padding:24px;box-sizing:border-box}
    .card{background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);padding:18px;border-radius:12px;display:flex;gap:16px;align-items:center;max-width:900px;width:100%;}
    .left{flex:1;display:flex;flex-direction:column;gap:12px;align-items:center}
    .hud{display:flex;gap:12px;align-items:center}
    .panel{background:var(--panel);padding:10px;border-radius:8px;min-width:100px;text-align:center}
    .score{font-weight:700;font-size:18px}
    canvas{background:#071525;border-radius:6px;display:block;max-width:100%;height:auto;box-shadow:0 6px 30px rgba(2,6,23,0.6)}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    button{background:var(--accent);border:none;color:#051018;padding:8px 12px;border-radius:8px;font-weight:600;cursor:pointer}
    button.secondary{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text)}
    .right{width:260px;display:flex;flex-direction:column;gap:12px}
    h1{margin:0;font-size:20px}
    p.small{margin:0;color:rgba(230,240,255,0.7);font-size:13px}
    footer{font-size:12px;color:rgba(230,240,255,0.6)}
    @media(max-width:780px){.card{flex-direction:column}.right{width:100%}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="left">
        <div class="hud">
          <div class="panel">
            <div>Score</div>
            <div class="score" id="score">0</div>
          </div>
          <div class="panel">
            <div>High</div>
            <div class="score" id="high">0</div>
          </div>
          <div class="controls">
            <button id="btnStart">Start</button>
            <button id="btnPause" class="secondary">Pause</button>
            <button id="btnReset" class="secondary">Reset</button>
          </div>
        </div>

        <canvas id="game" width="400" height="400" aria-label="Snake game canvas"></canvas>
        <p class="small">Use arrow keys or WASD. On mobile swipe to move. Press Space to pause/unpause.</p>
      </div>

      <div class="right">
        <h1>Snake Game</h1>
        <p class="small">Single-file HTML/CSS/JS snake game. The game plays on a grid; eat food to grow. Hitting walls or yourself ends the game.</p>
        <div class="panel" style="padding:12px">
          <strong>How to play</strong>
          <ul style="margin:8px 0 0 18px;padding:0;color:rgba(230,240,255,0.8)">
            <li>Arrow keys or WASD to move</li>
            <li>Space to pause/unpause</li>
            <li>Click Start to begin or Reset to restart</li>
            <li>Swipe on touch devices</li>
          </ul>
        </div>
        <div class="panel" style="padding:12px;display:flex;flex-direction:column;gap:6px">
          <div><strong>Tips</strong></div>
          <div class="small">Don't turn 180° directly. Plan moves to avoid trapping yourself.</div>
        </div>
        <footer>Made with ❤️ — enjoy!</footer>
      </div>
    </div>
  </div>

<script>
// ----------------------
// Snake game (vanilla JS)
// ----------------------
(function(){
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const highEl = document.getElementById('high');
  const btnStart = document.getElementById('btnStart');
  const btnPause = document.getElementById('btnPause');
  const btnReset = document.getElementById('btnReset');

  // Grid settings
  const GRID_SIZE = 20; // cells per row/column
  const CELL = Math.floor(canvas.width / GRID_SIZE); // pixel size per cell

  let snake = [];
  let dir = {x:1,y:0}; // start moving right
  let nextDir = {x:1,y:0};
  let food = null;
  let score = 0;
  let high = Number(localStorage.getItem('snake_high') || 0);
  let running = false;
  let gameInterval = null;
  let speed = 100; // ms between moves (lower = faster)

  highEl.textContent = high;

  function resetGame(){
    snake = [{x:8,y:10},{x:7,y:10},{x:6,y:10}];
    dir = {x:1,y:0};
    nextDir = {x:1,y:0};
    placeFood();
    score = 0;
    scoreEl.textContent = score;
    running = false;
    clearInterval(gameInterval);
    btnPause.textContent = 'Pause';
  }

  function placeFood(){
    while(true){
      const x = Math.floor(Math.random()*GRID_SIZE);
      const y = Math.floor(Math.random()*GRID_SIZE);
      // don't place on snake
      if(!snake.some(s=>s.x===x && s.y===y)){
        food = {x,y};
        return;
      }
    }
  }

  function draw(){
    // clear
    ctx.fillStyle = '#071525';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // draw grid lightly (optional)
    ctx.strokeStyle = 'rgba(255,255,255,0.02)';
    ctx.lineWidth = 1;
    for(let i=0;i<=GRID_SIZE;i++){
      ctx.beginPath();
      ctx.moveTo(i*CELL,0);
      ctx.lineTo(i*CELL,canvas.height);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0,i*CELL);
      ctx.lineTo(canvas.width,i*CELL);
      ctx.stroke();
    }

    // draw food
    if(food){
      ctx.fillStyle = '#ff6b6b';
      roundRect(ctx, food.x*CELL+4, food.y*CELL+4, CELL-8, CELL-8, 6, true, false);
    }

    // draw snake
    for(let i=0;i<snake.length;i++){
      const s = snake[i];
      const isHead = i===0;
      ctx.fillStyle = isHead ? '#00d1b2' : '#0fe3bf66';
      roundRect(ctx, s.x*CELL+2, s.y*CELL+2, CELL-4, CELL-4, 6, true, false);
    }
  }

  function roundRect(ctx, x, y, w, h, r) {
    if (w < 2 * r) r = w / 2;
    if (h < 2 * r) r = h / 2;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    ctx.fill();
  }

  function step(){
    // apply nextDir but prevent 180 turn
    if(!(nextDir.x === -dir.x && nextDir.y === -dir.y)) dir = nextDir;

    const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};

    // wrap-around behavior: if you prefer walls as death, change these checks
    // wrap edges:
    head.x = (head.x + GRID_SIZE) % GRID_SIZE;
    head.y = (head.y + GRID_SIZE) % GRID_SIZE;

    // check collision with self
    if(snake.some(seg => seg.x===head.x && seg.y===head.y)){
      gameOver();
      return;
    }

    snake.unshift(head);

    // eat food
    if(food && head.x===food.x && head.y===food.y){
      score += 10;
      scoreEl.textContent = score;
      placeFood();
      // optionally speed up
      if(speed>40) { speed -= 2; restartInterval(); }
    } else {
      snake.pop();
    }

    draw();
  }

  function gameOver(){
    running = false;
    clearInterval(gameInterval);
    if(score>high){
      high = score;
      localStorage.setItem('snake_high', String(high));
      highEl.textContent = high;
    }
    // simple flash effect
    flashCanvas();
  }

  function flashCanvas(){
    const orig = canvas.style.boxShadow;
    canvas.style.boxShadow = '0 0 0 6px rgba(255,107,107,0.2)';
    setTimeout(()=>{ canvas.style.boxShadow = orig; }, 250);
  }

  function startGame(){
    if(running) return;
    if(!snake.length) resetGame();
    running = true;
    restartInterval();
  }

  function restartInterval(){
    clearInterval(gameInterval);
    gameInterval = setInterval(step, speed);
  }

  // keyboard controls
  window.addEventListener('keydown', (e)=>{
    const key = e.key;
    if(key === 'ArrowUp' || key === 'w' || key === 'W') nextDir = {x:0,y:-1};
    if(key === 'ArrowDown' || key === 's' || key === 'S') nextDir = {x:0,y:1};
    if(key === 'ArrowLeft' || key === 'a' || key === 'A') nextDir = {x:-1,y:0};
    if(key === 'ArrowRight' || key === 'd' || key === 'D') nextDir = {x:1,y:0};
    if(key === ' '){ // space: pause/unpause
      e.preventDefault();
      togglePause();
    }
  });

  function togglePause(){
    if(!running){ startGame(); return; }
    running = !running;
    if(running) restartInterval(); else clearInterval(gameInterval);
    btnPause.textContent = running ? 'Pause' : 'Resume';
  }

  btnStart.addEventListener('click', ()=>{ startGame(); btnStart.blur(); });
  btnPause.addEventListener('click', ()=>{ togglePause(); btnPause.blur(); });
  btnReset.addEventListener('click', ()=>{ resetGame(); draw(); btnReset.blur(); });

  // touch / swipe controls for mobile
  let touchStart = null;
  canvas.addEventListener('touchstart', (e)=>{
    const t = e.touches[0];
    touchStart = {x: t.clientX, y: t.clientY};
  }, {passive:true});
  canvas.addEventListener('touchend', (e)=>{
    if(!touchStart) return;
    const t = e.changedTouches[0];
    const dx = t.clientX - touchStart.x;
    const dy = t.clientY - touchStart.y;
    const absX = Math.abs(dx); const absY = Math.abs(dy);
    const TH = 20; // minimum swipe distance
    if(Math.max(absX, absY) < TH) { touchStart = null; return; }
    if(absX > absY){
      nextDir = dx>0 ? {x:1,y:0} : {x:-1,y:0};
    } else {
      nextDir = dy>0 ? {x:0,y:1} : {x:0,y:-1};
    }
    touchStart = null;
  }, {passive:true});

  // keep canvas crisp on high-DPI
  function fixHiDPI(){
    const dpr = window.devicePixelRatio || 1;
    const cssW = canvas.clientWidth || canvas.width;
    const cssH = canvas.clientHeight || canvas.height;
    canvas.width = Math.floor(cssW * dpr);
    canvas.height = Math.floor(cssH * dpr);
    ctx.scale(dpr,dpr);
  }

  // initialize
  resetGame();
  draw();

  // responsive cell calculation: adjust CELL based on canvas size
  function recomputeCell(){
    // keep a square canvas
    const size = Math.min( Math.max(window.innerWidth*0.6, 260), 600 );
    canvas.style.width = size + 'px';
    canvas.style.height = size + 'px';
    // reset transformation
    ctx.setTransform(1,0,0,1,0,0);
    fixHiDPI();
  }
  window.addEventListener('resize', ()=>{ recomputeCell(); draw(); });
  recomputeCell();

})();
</script>
</body>
</html>
